= Strangling the Spring Monolith with Quarkus

In this section of the lab, you will strangle the monolith with Quarkus. 

Currently the Pet Clinic application is developed as a monolith. All of the application functionality is in a single app. Here is a high-level architecture diagram of the application.

image::images/microservices/monolith-architecture.png[width="300"]

Let's refactor the application architecture to leverage microservices. The service related modules are replaced by microservices. Also, each microservice has a database that only contains information for its related entity. Based on this approach, we have three microservices as shown in the diagram below. Each microservice has its own database.

image::images/microservices/microservices-architecture.png[width="600"]

The `vets-service` manages the data for vets. The service exposes a method for retrieving a list of vets and their associated specialites.

The `visits-service` manages the data for pet visits. This service exposes methods to perform CRUD operations for pet visits.

The `customers-service` manages the data for owners and pets. It is a composition of the original modules for owners and pets. This service is a composition since there is a tight-relationship between owners and pets. This approach makes it easy to handle the database relationships.

In the essense of time, you will only develop one of the microservice in this lab. You will develop the `vets-service`. We will provide the remaining microservices for you (`visits-service` and `customers-service`).

You will also update the petclinic web application to leverage the new `vets-service`.

== vets-service

In this section, you will develop the `vets-service`. 

The vets-service exposes the following endpoint:
[cols="1,1,2", options="header"]
|===
| HTTP Method | Endpoint | Description
| GET | /vets | Retrieves a list of vets and their associated specialties
|===

The vets-service has the following architecture:

image::images/microservices/vets-service-architecture.png[width="300"]

You will first develop the service and then refactor the web application to use the service.

=== Review code for vets-service
To help with development, there is a basic starter project for the vets-service.

. Checkout code from the following branch: @TODO-DARBY

. Open the project for `vets-service`

. Review the starter code for vets service View the following packages
.. Model: `org.acme.model`
.. Service: `org.acme.service`
.. Resource: `org.acme.rest`

. View the application configuration files in the directory: `src/main/resources`
.. `application.properties`
.. `import.sql`
+
[NOTE]
====
The `import.sql` file loads SQL statements when Hibernate ORM starts. This script can contain any SQL DML statements. Make sure to terminate each statement with a semicolon. This is useful to have a data set ready for your tests or demos.
====

== Add Resource method to Retrieve Vets

Now let's add the resource method to retrieve the vets from the database. Developing REST APIs with Quarkus is similar to using Spring Boot. Quarkus uses JAX-RS from the Microprofile spec. 

Here's a list of common annotations used for REST development.

[options="header"]
|===
| Spring Annotation | JAX-RS Annotation
| @RequestMapping | @Path
| @GetMapping | @GET 
| @PostMapping | @POST 
| @PutMapping | @PUT 
| @DeleteMapping | @DELETE
| @PathVariable | @PathParam
| @RequestParam | @QueryParam
|===


. Open the file: VetsResource.java
** Make note of the base path for the resource. The resource endpoint is :`/vets` 
+
----
@Path("/vets")
---- 

** Make note of the @Produces annotation. The endpoints for this resource will produce JSON content.
+
----
@Produces(MediaType.APPLICATION_JSON)
----

. Add the following code to inject the VetsService
+
----
    @Inject
    VetsService service;
---- 

. Add the method to retrieve the vets
----
    @GET
    public List<Vet> get() {
        LOG.debug("Inside get() method");
        return service.getAll();
    }
----

=== Run the vets-service

. Open a new Terminal window.

. Run the service with the following command:
+
----
$ cd quarkus-petclinic-vets-service

$ mvn clean quarkus:dev -Ddebug=7005
----

* The vets-service is configured to listen port 7070 (based on configs in `application.properties`). We also specify the debug port manually to avoid a port conflict with services that we will run later.
+
. Once the vets-service is running, you should see the following output.
+
----
Listening for transport dt_socket at address: 7005
__  ____  __  _____   ___  __ ____  ______
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
 -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/
2020-10-21 12:16:45,173 INFO  [io.agr.pool] (Quarkus Main Thread) Datasource '<default>': Initial size smaller than min. Connections will be created when necessary
2020-10-21 12:16:45,648 INFO  [io.quarkus] (Quarkus Main Thread) quarkus-petclinic-vets-service 1.0.0-SNAPSHOT on JVM (powered by Quarkus 1.8.1.Final) started in 2.367s. Listening on: http://0.0.0.0:7070
2020-10-21 12:16:45,650 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
2020-10-21 12:16:45,650 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, jdbc-h2, mutiny, narayana-jta, resteasy, resteasy-jackson, smallrye-context-propagation]
----

. Open a new terminal window

. Call the service using the curl command
+
----
curl http://localhost:7070/vets
----

. You should see the following output
+
----
{"id":1,"firstName":"James","lastName":"Carter","specialties":[]},{"id":2,"firstName":"Helen","lastName":"Leary","specialties":[{"id":1,"name":"radiology"}]},{"id":3,"firstName":"Linda","lastName":"Douglas","specialties":[{"id":2,"name":"surgery"},{"id":3,"name":"dentistry"}]},{"id":4,"firstName":"Rafael","lastName":"Ortega","specialties":[{"id":2,"name":"surgery"}]},{"id":5,"firstName":"Henry","lastName":"Stevens","specialties":[{"id":1,"name":"radiology"}]},{"id":6,"firstName":"Sharon","lastName":"Jenkins","specialties":[]}]
----

You have successfully created the REST endpoint for the vets-service :-)

== Refactor Web App to use vets-service

Now that you have the microservice developed for the `vets-service`, you'll refactor the web app to use the service.

The web app will need to make HTTP calls to the the vets-service. The web app could manually make the calls, however this approach requires a lot of boiler-plate code and it is error prone.

As an alternative, you can use the MicroProfile Rest Client. The MicroProfile REST Client makes it easy to interact with REST APIs with very little effort.

The MicroProfile Rest Client provides a type-safe approach to invoke RESTful services over HTTP. Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations.

Regarding Spring Cloud migration, *MicroProfile Rest Client* is similar to *Spring Cloud Feign*.

=== Add Maven Dependencies

. Move to `quarkus-petclinic` project

. Open the file: pom.xml

. Add the following dependencies:
+
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-rest-client</artifactId>
</dependency>

<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-resteasy-jackson</artifactId>
</dependency>
----
* `quarkus-rest-client` provides a Quarkus wrapper for the Microprofile Rest Client implementation

* `quarkus-resteasy-jackson` handles automatic serialization/deserialization of Java obects to/from JSON. Quarkus also supports JSON-B as a separate dependency.

=== Develop MicroProfile Rest Client for `vets-service`

Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations.

1. Create a new package: `org.acme.rest.client`

2. In this package, create a new interface: `VetsRestClient`

3. Add the following code:
+
----
package org.acme.rest.client;

import java.util.List;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.acme.model.Vet;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

@Path("/vets")
@RegisterRestClient
public interface VetsRestClient {

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<Vet> getAll();

}
----

* The `getAll` method gives our code the ability to retrieve a list of vets from the `vets-service`. The client will handle all the networking and marshalling leaving our code clean of such technical details.

* The purpose of the annotations in the code above is the following:

** `@RegisterRestClient` allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client

** `@Path` and `@GET` are the standard JAX-RS annotations used to define how to access the service

** `@Produces` defines the expected content-type
+
[NOTE]
====
While `@Consumes` and `@Produces` are optional as auto-negotiation is supported, it is heavily recommended to annotate your endpoints with them to define precisely the expected content-types.

It will allow to narrow down the number of JAX-RS providers (which can be seen as converters) included in the native executable.
====

=== Create the configuration

In order to determine the base URL to which REST calls will be made, the REST Client uses configuration from `application.properties`. The name of the property needs to follow a certain convention for naming.

. Make sure you are still in the `quarkus-petclinic` project

. Open the file: `src/main/resources/application.properties`

. Add the following configuration:
+
----
%dev.org.acme.rest.client.VetsRestClient/mp-rest/url=http://localhost:7070
%dev.org.acme.rest.client.VetsRestClient/mp-rest/scope=javax.inject.Singleton
----

* The first line for configuration means that all requests performed using `org.acme.rest.client.VetsRestClient` will use http://localhost:7070 as the base URL. Using the configuration above, calling the `getAll()`` method of `VetsRestClient` would result in an HTTP GET request being made to http://localhost:7070/vets. This configuration is prefixed with `%dev` for the DEV profile.

* The second line for configuration means that the default scope of `org.acme.rest.client.VetsRestClient` will be @Singleton. Supported scope values are @Singleton, @Dependent, @ApplicationScoped and @RequestScoped. The default scope is @Dependent. The default scope can also be defined on the interface.

[NOTE]
====
It is important that `org.acme.rest.client.VetsRestClient` must match the fully qualified name of the `VetsRestClient` interface we created in the previous section.
====

=== Update VetsResource

Now you'll modify the VetResource in your web app. Instead of communicating with the VetsService, instead you will use the VetsRestClient.

. Make sure you are still in the `quarkus-petclinic` project

. Move to the package: `org.acme.rest`

. Open the file: `VetsResource.java`

. Add the following code:
+
----
    @Inject
    @RestClient
    VetsRestClient vetsRestClient;
----

. Update the get() method with the following code:
+
----
    @GET
    @Produces(MediaType.TEXT_HTML)
    public TemplateInstance get() {

        LOG.debug("Calling vetsRestClient");
        List<Vet> data = vetsRestClient.getAll();
        LOG.debug("Received data from vetsRestClient: " + data);

        return vets.data("active", "vets")
                .data("vets", data);
    }
----
* Notice that we retrieve the list of vets from the `vetsRestClient`. This data is then placed into the Qute template for later display. 

. In `VetsResource.java`, you can delete all references to the `VetsService` class since we are no longer using it.

. Delete the file: `VetsService.java` in the package `org.acme.service`

. Make sure there are no compilation errors in your code.

=== View the Pet Clinic web app

. Open a web browser and view http://localhost:8080

. Click the link for *Vets*.
+
image::images/microservices/vets-navigation-link.png[]

. You should see the following output.
+
image::images/microservices/vets-list.png[]

=== Monolith Cleanup Work

Now that the `vets-service` is running as a separate Microservice, we can clean up some of the code in the Pet Clinic web app. In particular, we can clean up the following

** Remove database entries from import.sql
** Remove Panache support from Vet model objects

==== Remove database entries from import.sql

. Make sure you are still in the `quarkus-petclinic` project

. Move to the directory: `src/main/resources`

. Open the file: `import.sql`

. Delete the following lines:
+
----
INSERT INTO vets VALUES (1, 'James', 'Carter');
INSERT INTO vets VALUES (2, 'Helen', 'Leary');
INSERT INTO vets VALUES (3, 'Linda', 'Douglas');
INSERT INTO vets VALUES (4, 'Rafael', 'Ortega');
INSERT INTO vets VALUES (5, 'Henry', 'Stevens');
INSERT INTO vets VALUES (6, 'Sharon', 'Jenkins');

INSERT INTO specialties VALUES (1, 'radiology');
INSERT INTO specialties VALUES (2, 'surgery');
INSERT INTO specialties VALUES (3, 'dentistry');

INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 2, 1);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 3, 2);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 3, 3);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 4, 2);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 5, 1);
----

* This data is no longer required in the Pet Clinic web app because this data is now managed by the `vets-service`. The `vets-service` has a separate database for vet related data.

==== Remove Panache support from Vet model objects

At this point in the Pet Clinic web app, is a `client` to the `vets-service. As a result, the Vet model objects are simply data transfer objects (DTOs). Their is no longer requirement for the Pet Clinic web app to directly persist Vet model objects using Panache.

You can remove the Panache support from the Vet models objects.

. Make sure you are still in the `quarkus-petclinic` project

. Move to the package: `org.acme.model`

. Open the file: `Vet.java`

. Replace the content with following code:
+
----
package org.acme.model;

import java.util.List;

public class Vet {

	public long id;
	
	public String firstName;

	public String lastName;

    public List<Specialty> specialties;
	
}
----

. Open the file `Specialty.java`

. Replace the content with following code:
+
----
package org.acme.model;

import java.util.List;

public class Specialty {
  
    public long id;
    
    public String name;

    public List<Vet> vets;

}
----

. Test your app and verify that it works as desired.

Congratulations! You successfully retrieved a list of vets from the vets-service microservice. You also took the first major step of strangling the monolith application.
