= Strangling the Spring Monolith with Quarkus

In this section of the lab, you will strangle the monolith with Quarkus. 

Currently the Pet Clinic application is developed as a monolith. All of the application functionality is in a single app. Here is a high-level architecture diagram of the application.

image::images/microservices/monolith-architecture.png[width="300"]

Let's refactor the application architecture to leverage microservices. The service related modules are replaced by microservices. Also, each microservice has a database that only contains information for its related entity. Based on this approach, we have three microservices as shown in the diagram below. Each microservice has its own database.

image::images/microservices/microservices-architecture.png[width="600"]

The `vets-service` manages the data for vets. The service exposes a method for retrieving a list of vets and their associated specialites.

The `visits-service` manages the data for pet visits. This service exposes methods to perform CRUD operations for pet visits.

The `customers-service` manages the data for owners and pets. It is a composition of the original modules for owners and pets. This service is a composition since there is a tight-relationship between owners and pets. This approach makes it easy to handle the database relationships.

In the essense of time, you will only develop one of the microservice in this lab. You will develop the `vets-service`. We will provide the remaining microservices for you (`visits-service` and `customers-service`).

You will also update the petclinic web application to leverage the new `vets-service`.

== vets-service

In this section, you will develop the `vets-service`. 

The vets-service exposes the following endpoint:
[cols="1,1,2", options="header"]
|===
| HTTP Method | Endpoint | Description
| GET | /vets | Retrieves a list of vets and their associated specialties
|===

The vets-service has the following architecture:

image::images/microservices/vets-service-architecture.png[width="300"]

You will first develop the service and then refactor the web application to use the service.

=== Review code for vets-service
To help with development, there is a basic starter project for the vets-service.

. Open the project for `vets-service`

. Review the starter code for vets service View the following packages
.. Model: `org.acme.model`
.. Service: `org.acme.service`
.. Resource: `org.acme.rest`

. View the application configuration files in the directory: `src/main/resources`
.. `application.properties`
.. `import.sql`
+
[NOTE]
====
The `import.sql` file loads SQL statements when Hibernate ORM starts. This script can contain any SQL DML statements. Make sure to terminate each statement with a semicolon. This is useful to have a data set ready for your tests or demos.
====

== Add Resource method to Retrieve Vets

Now let's add the resource method to retrieve the vets from the database. Developing REST APIs with Quarkus is similar to using Spring Boot. Quarkus uses JAX-RS from the Microprofile spec. 

Here's a list of common annotations used for REST development.

[options="header"]
|===
| Spring Annotation | JAX-RS Annotation
| @RequestMapping | @Path
| @GetMapping | @GET 
| @PostMapping | @POST 
| @PutMapping | @PUT 
| @DeleteMapping | @DELETE
| @PathVariable | @PathParam
| @RequestParam | @QueryParam
|===


. Open the file: VetsResource.java
** Make note of the base path for the resource. The resource endpoint is :`/vets` 
+
----
@Path("/vets")
---- 

** Make note of the @Produces annotation. The endpoints for this resource will produce JSON content.
+
----
@Produces(MediaType.APPLICATION_JSON)
----

. Add the following code to inject the VetsService
+
----
    @Inject
    VetsService service;
---- 

. Add the method to retrieve the vets
----
    @GET
    public List<Vet> get() {
        LOG.debug("Inside get() method");
        return service.getAll();
    }
----

=== Run the vets-service

. Open a new Terminal window.

. Run the service with the following command:
+
----
$ cd quarkus-petclinic-vets-service

$ mvn clean quarkus:dev -Ddebug=7005
----

* The vets-service is configured to listen port 7070 (based on configs in `application.properties`). We also specify the debug port manually to avoid a port conflict with services that we will run later.
+
. Once the vets-service is running, you should see the following output.
+
----
Listening for transport dt_socket at address: 7005
__  ____  __  _____   ___  __ ____  ______
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
 -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/
2020-10-21 12:16:45,173 INFO  [io.agr.pool] (Quarkus Main Thread) Datasource '<default>': Initial size smaller than min. Connections will be created when necessary
2020-10-21 12:16:45,648 INFO  [io.quarkus] (Quarkus Main Thread) quarkus-petclinic-vets-service 1.0.0-SNAPSHOT on JVM (powered by Quarkus 1.8.1.Final) started in 2.367s. Listening on: http://0.0.0.0:7070
2020-10-21 12:16:45,650 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
2020-10-21 12:16:45,650 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, jdbc-h2, mutiny, narayana-jta, resteasy, resteasy-jackson, smallrye-context-propagation]
----

. Open a new terminal window

. Call the service using the curl command
+
----
curl http://localhost:7070/vets
----

. You should see the following output
+
----
{"id":1,"firstName":"James","lastName":"Carter","specialties":[]},{"id":2,"firstName":"Helen","lastName":"Leary","specialties":[{"id":1,"name":"radiology"}]},{"id":3,"firstName":"Linda","lastName":"Douglas","specialties":[{"id":2,"name":"surgery"},{"id":3,"name":"dentistry"}]},{"id":4,"firstName":"Rafael","lastName":"Ortega","specialties":[{"id":2,"name":"surgery"}]},{"id":5,"firstName":"Henry","lastName":"Stevens","specialties":[{"id":1,"name":"radiology"}]},{"id":6,"firstName":"Sharon","lastName":"Jenkins","specialties":[]}]
----

You have successfully created the REST endpoint for the vets-service :-)

== Refactor Web App to use vets-service

Now that you have the microservice developed for the `vets-service`, you'll refactor the web app to use the service.

The web app will need to make HTTP calls to the the vets-service. The web app could manually make the calls, however this approach requires a lot of boiler-plate code and it is error prone.

As an alternative, you can use the MicroProfile Rest Client. The MicroProfile REST Client makes it easy to interact with REST APIs with very little effort.

The MicroProfile Rest Client provides a type-safe approach to invoke RESTful services over HTTP. Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations.

=== Add Maven Dependencies

. Move to `quarkus-petclinic` project

. Open the file: pom.xml

. Add the following dependencies:
+
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-rest-client</artifactId>
</dependency>

<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-resteasy-jackson</artifactId>
</dependency>
----
* `quarkus-rest-client` provides a Quarkus wrapper for the Microprofile Rest Client implementation

* `quarkus-resteasy-jackson` handles automatic serialization/deserialization of Java obects to/from JSON. Quarkus also supports JSON-B as a separate dependency.

=== Develop MicroProfile Rest Client for `vets-service`

Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations.

1. Create a new package: `org.acme.rest.client`

2. In this package, create a new interface: `VetsRestClient`

3. Add the following code:
+
----
package org.acme.rest.client;

import java.util.List;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.acme.model.Vet;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

@Path("/vets")
@RegisterRestClient
public interface VetsRestClient {

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List<Vet> getAll();

}
----

* The `getAll` method gives our code the ability to retrieve a list of vets from the `vets-service`. The client will handle all the networking and marshalling leaving our code clean of such technical details.

* The purpose of the annotations in the code above is the following:

** `@RegisterRestClient` allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client

** `@Path` and `@GET` are the standard JAX-RS annotations used to define how to access the service

** `@Produces` defines the expected content-type
+
[NOTE]
====
While `@Consumes` and `@Produces` are optional as auto-negotiation is supported, it is heavily recommended to annotate your endpoints with them to define precisely the expected content-types.

It will allow to narrow down the number of JAX-RS providers (which can be seen as converters) included in the native executable.
====