= Spring Data JPA to Quarkus Hibernate ORM with Panache
:experimental:

*Spring Data JPA* enables Java developers to implement JPA-based repositories but also quickly to build applications with data access technology. Implementing the data access layer of an application has been a hassle for quite some time. To perform simple queries, pagination and auditing, you need to write boilerplate code. Spring Data JPA aims to improve the implementation of the data access layer by creating repository interfaces and custom finder methods. 

For example, let's take a look at the `OwnerRepository` class in `src/main/java/org/springframework/samples/petclinic/owner` of Spring Petclinic application. This   repository class showcases how to execute JPA queries and and save an object to the data store:

[source,java]
----
public interface OwnerRepository extends Repository<Owner, Integer> {

	/**
	 * Retrieve {@link Owner}s from the data store by last name, returning all owners
	 * whose last name <i>starts</i> with the given name.
	 * @param lastName Value to search for
	 * @return a Collection of matching {@link Owner}s (or an empty Collection if none
	 * found)
	 */
	@Query("SELECT DISTINCT owner FROM Owner owner left join fetch owner.pets WHERE owner.lastName LIKE :lastName%")
	@Transactional(readOnly = true)
	Collection<Owner> findByLastName(@Param("lastName") String lastName);

	/**
	 * Retrieve an {@link Owner} from the data store by id.
	 * @param id the id to search for
	 * @return the {@link Owner} if found
	 */
	@Query("SELECT owner FROM Owner owner left join fetch owner.pets WHERE owner.id =:id")
	@Transactional(readOnly = true)
	Owner findById(@Param("id") Integer id);

	/**
	 * Save an {@link Owner} to the data store, either inserting or updating it.
	 * @param owner the {@link Owner} to save
	 */
	void save(Owner owner);

}
----

Here are more use cases how the presentation layer maps to the persistence layer using Spring Data JPA in Spring Petclinic application:

* Vets displays all vets and their specialties
* FindOwners is used to find owners by last name
* FindOwnersRedirect redirects to findOwner
* SelectOwner allows user to select from a list of multiple owners with the same last name
* Owner displays a owner's data and a list of the owner's pets and their data
* OwnerRedirect redirects to owner
* Owner supports AddOwnerForm and EditOwnerForm
* Pet supports AddPetForm and EditPetForm
* Visit supports AddVisitForm

Spring Petclinic application also supports 3 types of database such as *H2*, *HSQL*, and *MYSQL* below. In the previous lab, we used the _H2 in-memory database_ to store business data(i.e. vets, pets, owners):

image::spring-db-structure.png[quarkus, 400]

In this lab, we'll learn how simply refactor *Spring Data JPA* to *Quarkus Hibernate ORM with Panache*. Because _Hibernate ORM_ is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but it does not make simple and common mappings trivial. _Hibernate ORM with Panache_ focuses on making your entities trivial and fun to write in _Quarkus_.

When it comes to writing *Hibernate ORM* entities, there are a number of annoying things that users have grown used to reluctantly deal with, such as:

* Duplicating ID logic: most entities need an ID, most people don’t care how it’s set, because it’s not really relevant to your model.
* Dumb getters and setters: since Java lacks support for properties in the language, we have to create fields, then generate getters and setters for those fields, even if they don’t actually do anything more than read/write the fields.
* Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them (DAOs, Repositories), but really that requires an unnatural split between the state and its operations even though we would never do something like that for regular objects in the Object Oriented architecture, where state and methods are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you’re writing to set up an injection point before coming back to use it.
* Hibernate queries are super powerful, but overly verbose for common operations, requiring you to write queries even when you don’t need all the parts.
* Hibernate is very general-purpose, but does not make it trivial to do trivial operations that make up 90% of our model usage.

With *Panache*, we took an opinionated approach to tackle all these problems:

* Make your entities extend *PanacheEntity*: it has an ID field that is auto-generated. If you require a custom ID strategy, you can extend *PanacheEntityBase* instead and handle the ID yourself.
* Use public fields. *Get rid of dumb getter and setters*. Under the hood, we will generate all getters and setters that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still write useful accessors when you need them, which will be used even though your entity users still use field accesses.
* With the active record pattern: put all your entity logic in static methods in your entity class and *don’t create DAOs*. Your entity superclass comes with lots of super useful static methods, and you can add your own in your entity class. Users can just start using your entity(i.e _Person_) by typing it and getting completion for all the operations in a single place.
* Don’t write parts of the query that you don’t need. For exampe, write *Person.find("order by name")* or *Person.find("name = ?1 and status = ?2", "stef", Status.Alive)* or even better *Person.find("name", "stef")*.

That’s all there is to it: with Panache, Hibernate ORM has never looked so trim and neat.

== Setting up and configuring Hibernate ORM with Panache

We'll add Quarkus extensions to the Quarkus Petclinic application for using _Panache_ that simplifies access to data via Hibernate ORM for local development. RESTEasy has rich support for the `multipart/*` and `multipart/form-data` mime types. The multipart mime format is used to pass lists of content bodies. Multiple content bodies are embedded in one message. We'll also use this _multipart/form-data_ in the Quarkus Petclinic application.

Run the following commands to add the extensions using CodeReady Workspaces Terminal:

[source,java,role="copypaste"]
----
mvn -q quarkus:add-extension -Dextensions="hibernate-orm-panache, jdbc-h2, multipart-provider" -f $CHE_PROJECTS_ROOT/quarkus-workshop-labs
----

You should see:

[source,console]
----
✅ Adding extension io.quarkus:quarkus-hibernate-orm-panache
✅ Adding extension io.quarkus:quarkus-jdbc-h2
----

Quarkus supports the notion of _configuration profiles_. These allows you to have multiple configurations in the same file and select between then via a _profile name_.

By default Quarkus has three profiles, although it is possible to use as many as you like. The default profiles are:

* `dev` - Activated when in development mode (i.e. *quarkus:dev*)
* `test` - Activated when running tests
* `prod` - The default profile when not running in development or test mode

Let’s add the following variables to set the database connection details(JDBC url, database credentials) in `src/main/resources/application.properties`:

[source,properties,role="copypaste"]
----
%dev.quarkus.datasource.url=jdbc:h2:mem:default;DB_CLOSE_DELAY=-1
%dev.quarkus.datasource.driver=org.h2.Driver
%dev.quarkus.datasource.username=petclinic
%dev.quarkus.datasource.password=mysecretpassword
%dev.quarkus.datasource.max-size=8
%dev.quarkus.datasource.min-size=2
%dev.quarkus.hibernate-orm.database.generation=drop-and-create
%dev.quarkus.hibernate-orm.log.sql=false
----