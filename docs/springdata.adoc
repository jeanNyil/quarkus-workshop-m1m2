= Spring Data JPA to Quarkus Hibernate ORM with Panache
:experimental:

*Spring Data JPA* enables Java developers to implement JPA-based repositories but also quickly to build applications with data access technology. Implementing the data access layer of an application has been a hassle for quite some time. To perform simple queries, pagination and auditing, you need to write boilerplate code. Spring Data JPA aims to improve the implementation of the data access layer by creating repository interfaces and custom finder methods. 

For example, let's take a look at the `OwnerRepository` class in `src/main/java/org/springframework/samples/petclinic/owner` of Spring Petclinic application. This   repository class showcases how to execute JPA queries and and save an object to the data store:

[source,java]
----
public interface OwnerRepository extends Repository<Owner, Integer> {

	/**
	 * Retrieve {@link Owner}s from the data store by last name, returning all owners
	 * whose last name <i>starts</i> with the given name.
	 * @param lastName Value to search for
	 * @return a Collection of matching {@link Owner}s (or an empty Collection if none
	 * found)
	 */
	@Query("SELECT DISTINCT owner FROM Owner owner left join fetch owner.pets WHERE owner.lastName LIKE :lastName%")
	@Transactional(readOnly = true)
	Collection<Owner> findByLastName(@Param("lastName") String lastName);

	/**
	 * Retrieve an {@link Owner} from the data store by id.
	 * @param id the id to search for
	 * @return the {@link Owner} if found
	 */
	@Query("SELECT owner FROM Owner owner left join fetch owner.pets WHERE owner.id =:id")
	@Transactional(readOnly = true)
	Owner findById(@Param("id") Integer id);

	/**
	 * Save an {@link Owner} to the data store, either inserting or updating it.
	 * @param owner the {@link Owner} to save
	 */
	void save(Owner owner);

}
----

Here are more use cases how the presentation layer maps to the persistence layer using Spring Data JPA in Spring Petclinic application:

* Vets displays all vets and their specialties
* FindOwners is used to find owners by last name
* FindOwnersRedirect redirects to findOwner
* SelectOwner allows user to select from a list of multiple owners with the same last name
* Owner displays a owner's data and a list of the owner's pets and their data
* OwnerRedirect redirects to owner
* Owner supports AddOwnerForm and EditOwnerForm
* Pet supports AddPetForm and EditPetForm
* Visit supports AddVisitForm

Spring Petclinic application also supports 3 types of database such as *H2*, *HSQL*, and *MYSQL* below. In the previous lab, we used the _H2 in-memory database_ to store business data(i.e. vets, pets, owners):

image::spring-db-structure.png[quarkus, 400]

In this lab, we'll learn how simply refactor *Spring Data JPA* to *Quarkus Hibernate ORM with Panache*. Because _Hibernate ORM_ is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but it does not make simple and common mappings trivial. _Hibernate ORM with Panache_ focuses on making your entities trivial and fun to write in _Quarkus_.

When it comes to writing *Hibernate ORM* entities, there are a number of annoying things that users have grown used to reluctantly deal with, such as:

* Duplicating ID logic: most entities need an ID, most people don’t care how it’s set, because it’s not really relevant to your model.
* Dumb getters and setters: since Java lacks support for properties in the language, we have to create fields, then generate getters and setters for those fields, even if they don’t actually do anything more than read/write the fields.
* Traditional EE patterns advise to split entity definition (the model) from the operations you can do on them (DAOs, Repositories), but really that requires an unnatural split between the state and its operations even though we would never do something like that for regular objects in the Object Oriented architecture, where state and methods are in the same class. Moreover, this requires two classes per entity, and requires injection of the DAO or Repository where you need to do entity operations, which breaks your edit flow and requires you to get out of the code you’re writing to set up an injection point before coming back to use it.
* Hibernate queries are super powerful, but overly verbose for common operations, requiring you to write queries even when you don’t need all the parts.
* Hibernate is very general-purpose, but does not make it trivial to do trivial operations that make up 90% of our model usage.

With *Panache*, we took an opinionated approach to tackle all these problems:

* Make your entities extend *PanacheEntity*: it has an ID field that is auto-generated. If you require a custom ID strategy, you can extend *PanacheEntityBase* instead and handle the ID yourself.
* Use public fields. *Get rid of dumb getter and setters*. Under the hood, we will generate all getters and setters that are missing, and rewrite every access to these fields to use the accessor methods. This way you can still write useful accessors when you need them, which will be used even though your entity users still use field accesses.
* With the active record pattern: put all your entity logic in static methods in your entity class and *don’t create DAOs*. Your entity superclass comes with lots of super useful static methods, and you can add your own in your entity class. Users can just start using your entity(i.e _Person_) by typing it and getting completion for all the operations in a single place.
* Don’t write parts of the query that you don’t need. For exampe, write *Person.find("order by name")* or *Person.find("name = ?1 and status = ?2", "stef", Status.Alive)* or even better *Person.find("name", "stef")*.

That’s all there is to it: with Panache, Hibernate ORM has never looked so trim and neat.

== Setting up and configuring Hibernate ORM with Panache

We'll add Quarkus extensions to the Quarkus Petclinic application for using _Panache_ that simplifies access to data via Hibernate ORM for local development. 

Open a new CodeReady Workspaces Terminal and run the following commands to add the extensions:

[source,console,role="copypaste"]
----
mvn -q quarkus:add-extension -Dextensions="hibernate-orm-panache, jdbc-h2" -f $CHE_PROJECTS_ROOT/quarkus-workshop-labs/quarkus-petclinic
----

You should see:

[source,console]
----
✅ Extension io.quarkus:quarkus-hibernate-orm-panache has been installed
✅ Extension io.quarkus:quarkus-jdbc-h2 has been installed
----

Quarkus supports the notion of _configuration profiles_. These allows you to have multiple configurations in the same file and select between then via a _profile name_.

By default Quarkus has three profiles, although it is possible to use as many as you like. The default profiles are:

* `dev` - Activated when in development mode (i.e. *quarkus:dev*)
* `test` - Activated when running tests
* `prod` - The default profile when not running in development or test mode

Add the following variables to set the database connection details(JDBC url, database credentials) in `src/main/resources/application.properties`:

[source,properties,role="copypaste"]
----
%dev.quarkus.datasource.url=jdbc:h2:mem:default;DB_CLOSE_DELAY=-1
%dev.quarkus.datasource.driver=org.h2.Driver
%dev.quarkus.datasource.username=petclinic
%dev.quarkus.datasource.password=mysecretpassword
%dev.quarkus.datasource.max-size=8
%dev.quarkus.datasource.min-size=2
%dev.quarkus.hibernate-orm.database.generation=drop-and-create
%dev.quarkus.hibernate-orm.log.sql=false
----

== Create Vet Entity

With our extension installed, we can now define our entity using Panache.

We’ll first need to edit `Vet.java` class file in `src/main/java/org/acme/model`, and add the following code under the `// TODO: Add Entity and Cacheable annotation` comment:

[source,java,role="copypaste"]
----
@Entity(name="vets") // <1>
@Cacheable // <2>
----

<1> Specify the table name(_vets_) in the database that is referred by the entity object(_Vet_).
<2> When an entity is annotated with _@Cacheable_, all its field values are cached except for collections and relations to other entities. This means the entity can be loaded quicker without querying the database for frequently-accessed, but rarely-changing data.


Extend `PanacheEntity` in your `Vet` entity. It should look like:

[source,java]
----
public class Vet extends PanacheEntity {

....

}
----

Add the following code under the `// TODO: Add Column and NotEmpty annotation for firstName` comment:

[source,java,role="copypaste"]
----
	@Column(name = "first_name")
	@NotEmpty
----

Add the following code under the `// TODO: Add Column and NotEmpty annotation for lastName` comment:

[source,java,role="copypaste"]
----
	@Column(name = "last_name")
	@NotEmpty
----

Map a bidirectional many-to-many association as same as Spring Petclinic appliation. Add the following code under the `// TODO: Add the list of Specialty` comment:

[source,java,role="copypaste"]
----
	@ManyToMany
	@JoinTable(
		name = "vet_Specialties",
		joinColumns = @JoinColumn(name = "vet_id"),
  		inverseJoinColumns = @JoinColumn(name = "specialty_id"))
    public List<Specialty> specialties;
----

Remove or comment the testing code that we added in the previous lab. Because we'll access the data layer directly but nore more need to have the dumb getters and setters:

[source,java]
----
    // public String getFirstName() {
    //     return this.firstName;
    // }
    // public void setFirstName(String firstName) {
    //     this.firstName = firstName;
    // }
    // public String getLastName() {
    //     return this.lastName;
    // }
    // public void setLasttName(String lastName) {
    //     this.lastName = lastName;
    // }
    // public static List<Vet> listAll(){
    //     Vet vet = new Vet();
    //     vet.setFirstName("Daniel");
    //     vet.setLasttName("Oh");
    //     List vets = new ArrayList<Vet>();
    //     vets.add(vet);
    //     return vets;
    // }
----

Don't forget to import required packages. Add the following code under the `// TODO: Import packages` comment:

[source,java,role="copypaste"]
----
import javax.persistence.Cacheable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.validation.constraints.NotEmpty;

import io.quarkus.hibernate.orm.panache.PanacheEntity;
----

Create a new entity, _Specialty_. Open an empty `Specialty.java` class file in `src/main/java/org/acme/model`, and add the following code:

[source,java,role="copypaste"]
----
package org.acme.model;

import java.util.List;

import javax.persistence.Cacheable;
import javax.persistence.Entity;
import javax.persistence.ManyToMany;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

@Entity(name="specialties")
@Cacheable
public class Specialty extends PanacheEntity {
  
    public String name;

    @ManyToMany(mappedBy = "specialties")
    public List<Vet> vets;

}
----

Edit the presentation layer to show the actual data. Open the `vets.html` in `src/main/resources/templates`, and add the following code under the `<!-- TODO: Add a for loop to list specialty -->`:

[source,html,role="copypaste"]
----
                    {#for specialty in vet.specialties}
                        {specialty.name} 
                    {/for}
----

Don't forget to remove the dummy code, `none` in the HTML.

Create a relation entity between _Specialty_ and _Vet_. Open an empty `VetSpecialty.java` class file in `src/main/java/org/acme/model`, and add the following code:

[source,java,role="copypaste"]
----
package org.acme.model;

import javax.persistence.Cacheable;
import javax.persistence.Column;
import javax.persistence.Entity;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

@Entity(name="vet_specialties")
@Cacheable
public class VetSpecialty extends PanacheEntity {

    @Column(name = "vet_id")
    public Long vetId;

    @Column(name = "specialty_id")
	public Long specialtyId;
    
}
----

Let’s add vets data to the database so we can test things out. Open up the `src/main/resources/import.sql` file and copy the following SQL statements to *import.sql*:

[source,sql,role="copypaste"]
----
INSERT INTO vets VALUES (1, 'James', 'Carter');
INSERT INTO vets VALUES (2, 'Helen', 'Leary');
INSERT INTO vets VALUES (3, 'Linda', 'Douglas');
INSERT INTO vets VALUES (4, 'Rafael', 'Ortega');
INSERT INTO vets VALUES (5, 'Henry', 'Stevens');
INSERT INTO vets VALUES (6, 'Sharon', 'Jenkins');

INSERT INTO specialties VALUES (1, 'radiology');
INSERT INTO specialties VALUES (2, 'surgery');
INSERT INTO specialties VALUES (3, 'dentistry');

INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 2, 1);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 3, 2);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 3, 3);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 4, 2);
INSERT INTO vet_specialties (id, vet_id, specialty_id) VALUES (nextval('hibernate_sequence'), 5, 1);
----

We don't need to create schema(i.e. vets, specialties) in database as we had to do in Spring Petclinic application as below:

image::spring-schema.png[spring-schema.png, 900]

Go back to the _Quarkus Petclinic_ page in your browser, click on the `VETERINARIAN` menu then you should see the following rendered page:

image::quarkus-vets-data.png[spring-schema.png, 900]

Now, we’ve succeeded to refactor _Spring_ Petclinic to _Quarkus_ Clinic application:

image::quarkus-spring-vets-data.png[spring-schema.png, 900]
